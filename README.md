## Лабораторная работа 3: Потоки, синхронизация и гонки данных

Группа: 11  
Подгруппа: A  
Студент: Бельский Тимофей Дмитриевич
Вариант: 1

---

### Цель работы
Понять модель потоков в Linux, научиться обнаруживать и устранять гонки данных, освоить примитивы синхронизации и изучить, где видны потоки в системе.

---

### Краткое описание выполненных заданий

#### Задание A: Гонка данных и её устранение
Реализована программа с N потоками, инкрементирующими общий счётчик M раз в трёх режимах:
- Без синхронизации (режим unsync) — продемонстрирована гонка данных
- С использованием мьютексов (режим mutex) — корректный результат
- С использованием атомарных операций (режим atomic) — корректный результат с лучшей производительностью

Проведены замеры производительности для разного количества потоков (1, 2, 4, 8) и проанализировано влияние синхронизации на корректность и скорость выполнения.

#### Задание B: Producer-Consumer (ограниченный буфер)
Реализована фиксированная кольцевая очередь с несколькими производителями и потребителями:
- Использована синхронизация через pthread_mutex_t и pthread_cond_t
- Корректное завершение потребителей через флаги завершения и pthread_cond_broadcast
- Проверка корректности по количеству и сумме обработанных элементов
- Замеры производительности для разных конфигураций (1-4 производителя/потребителя)

#### Задание C: Анализ видимости потоков в системе
Проведён анализ потоков в Linux с использованием системных команд:
- ps -L для отображения потоков процесса
- /proc/<PID>/status для получения количества потоков
- /proc/<PID>/task для просмотра файловой структуры потоков

Демонстрируется, как потоки представлены в системе и как их можно анализировать стандартными инструментами.

---

### Структура репозитория
```bash
lab3/
└── gr11subA/
    └── Бельский_Тимофей/
        ├── REPORT.MD        
        ├── README.md         
        └── src/
            ├── partA/        
            │   ├── thread_race.c
            │   └── Makefile
            ├── partB/          
            │   ├── prodcons.c
            │   └── Makefile
            └── partC/         
                ├── threads_info.sh
                └── Makefile
```

---

### Как запустить

#### Задание A:
```
cd src/partA
make
make run_unsync    # Режим без синхронизации
make run_mutex     # Режим с мьютексами
make run_atomic    # Режим с атомиками
```

#### Задание B:
```
cd src/partB
make
make run           # Запуск с параметрами по умолчанию
make run_custom ARGS="-P 2 -C 2 -N 100000 -B 64"  # Запуск с пользовательскими параметрами
```

#### Задание C:
```
cd src/partC
make               # Анализ потоков
```

---

### Ключевые выводы
1. Гонки данных легко возникают при отсутствии синхронизации, приводя к некорректным результатам.
2. Атомарные операции обеспечивают лучшую производительность по сравнению с мьютексами при сохранении корректности.
3. Синхронизация увеличивает время выполнения из-за накладных расходов на блокировки и конкуренцию за ресурсы.
4. Потоки в Linux видны через стандартные инструменты (ps, /proc), что позволяет анализировать их состояние и поведение.

---

### Использование AI
AI помогал:
- объяснять работу примитивов синхронизации
- предлагать оптимизации для уменьшения contention
- интерпретировать результаты замеров производительности
